from __future__ import annotations
from fastavro._read import block_reader
from typing import Dict, Any, Union, List, Callable, IO, Optional
from ast import (
    AST,
    Add,
    Assign,
    Attribute,
    AugAssign,
    Call,
    Compare,
    Constant,
    Dict as DictLiteral,
    Eq,
    Expr,
    Expr,
    For,
    FunctionDef,
    Gt,
    If,
    Import,
    ImportFrom,
    List as ListLiteral,
    Load,
    Lt,
    Module,
    Mult,
    Name,
    NotEq,
    Pass,
    Return,
    Store,
    Subscript,
    While,
    alias,
    arg,
    arguments,
    dump,
    fix_missing_locations,
    keyword,
    parse,
    unparse,
    walk,
)


PRIMITIVE_READERS = {
    "string": "read_utf8",
    "int": "read_long",
    "long": "read_long",
    "float": "read_float",
    "double": "read_double",
    "boolean": "read_boolean",
    "bytes": "read_bytes",
    "null": "read_null",
}

LOGICAL_READERS = {
    "decimal": "read_decimal",
    "uuid": "read_uuid",
    "date": "read_date",
    "time-millis": "read_time_millis",
    "time-micros": "read_time_micros",
    "timestamp-millis": "read_timestamp_millis",
    "timestamp-micros": "read_timestamp_micros",   }


SchemaType = Union[
    str, # Primitives
    List['SchemaType'], # Unions
    Dict[str, Any], # Complex types
]


def read_file(fo: IO[bytes]) -> Iterator[any]:
    """
    Open an Avro Container Format file. Read its header to find the schema,
    compile the schema, and use it to deserialize records, yielding them out.
    """
    blocks = block_reader(fo)
    sp = SchemaParser(blocks.writer_schema)
    reader = sp.compile()

    for block in blocks:
        for _ in range(block.num_records):
            yield reader(block.bytes_)


class SchemaParser:
    schema: SchemaType
    variable_count: int

    file_reader: Optional[Callable[[IO[bytes]], Any]]
    schemaless_reader: Optional[Callable[[IO[bytes]], Any]]

    def __init__(self, schema: SchemaType):
        self.schema = schema
        self.variable_count = 0

    def new_variable(self) -> str:
        """
        Returns a new name for a variable which is guaranteed to be unique.
        """
        self.variable_count += 1
        return f"v{self.variable_count}"

    def compile(self, populate_linecache=True) -> Callable[[IO[bytes]], Any]:
        """
        Compile the schema and return a callable function which will read from a
        file-like byte source and produce a value determined by schema.
        """
        module = self.generate_module()

        if populate_linecache:
            import linecache
            source_code = unparse(module)
            filename = f"autogenerated_file.py"
            compiled = compile(source_code, filename, mode="exec")
            source_lines = source_code.splitlines()
            linecache.cache[filename] = (len(source_lines), None, source_lines, filename)
        else:
            filename = "<generated>"
            compiled = compile(module, filename, mode="exec")
        namespace = {}
        exec(compiled, namespace)
        self.schemaless_reader = namespace["reader"]

        return self.schemaless_reader

    def generate_module(self) -> Module:
        import_from_fastavro_read = []
        for reader in PRIMITIVE_READERS.values():
            import_from_fastavro_read.append(alias(name=reader))
        for reader in LOGICAL_READERS.values():
            import_from_fastavro_read.append(alias(name=reader))

        body = [
            Import(names=[alias(name="decimal")]),
            ImportFrom(
                module="fastavro._read",
                names=import_from_fastavro_read,
                level=0,
            ),
            self.generate_reader_func(),
        ]
        module = Module(
            body=body,
            type_ignores=[],
        )
        module = fix_missing_locations(module)
        return module

    def generate_reader_func(self) -> FunctionDef:
        """
        Returns an AST describing a function which can read an Avro message from a
        IO[bytes] source. The message is parsed according to the SchemaParser's
        schema.
        """
        src_var = Name(id="src", ctx=Load())
        result_var = Name(id=self.new_variable(), ctx=Store())
        func = FunctionDef(
            name="reader",
            args=arguments(
                args=[arg("src")],
                posonlyargs=[],
                kwonlyargs=[],
                kw_defaults=[],
                defaults=[],
            ),
            body=[],
            decorator_list=[],
        )
        func.body.extend(self._gen_reader(self.schema, src_var, result_var))
        func.body.append(Return(value=Name(id=result_var.id, ctx=Load())))
        return func

    def _gen_reader(self, schema: SchemaType, src: Name, dest: AST) -> List[AST]:
        """
        Returns a sequence of statements which will read data from src and write
        the deserialized value into dest.
        """
        if isinstance(schema, str):
            if schema in PRIMITIVE_READERS.keys():
                return self._gen_primitive_reader(
                    primitive_type=schema, src=src, dest=dest
                )
            else:
                # TODO: Named type reference.
                pass
        if isinstance(schema, list):
            return self._gen_union_reader(
                options=schema,
                src=src,
                dest=dest,
            )
        if isinstance(schema, dict):
            if "logicalType" in schema:
                return self._gen_logical_reader(
                    schema=schema,
                    src=src,
                    dest=dest,
                )
            schema_type = schema["type"]
            if schema_type in PRIMITIVE_READERS.keys():
                return self._gen_primitive_reader(
                    primitive_type=schema_type,
                    src=src,
                    dest=dest,
                )
            if schema_type == "record":
                return self._gen_record_reader(
                    schema=schema,
                    src=src,
                    dest=dest,
                )
            if schema_type == "array":
                return self._gen_array_reader(
                    item_schema=schema["items"],
                    src=src,
                    dest=dest,
                )
            if schema_type == "map":
                return self._gen_map_reader(
                    value_schema=schema["values"],
                    src=src,
                    dest=dest,
                )
            if schema_type == "fixed":
                return self._gen_fixed_reader(
                    size=schema["size"],
                    src=src,
                    dest=dest,
                )
            if schema_type == "enum":
                return self._gen_enum_reader(
                    symbols=schema["symbols"],
                    default=schema.get("default"),
                    src=src,
                    dest=dest,
                )

        raise NotImplementedError(f"Schema type not implemented: {schema}")

    def _gen_union_reader(self, options: List[SchemaType], src: Name, dest: AST) -> List[AST]:
        statements = []
        # Read a long to figure out which option in the union is chosen.
        idx_var = self.new_variable()
        idx_var_dest = Name(id=idx_var, ctx=Store())
        statements.extend(self._gen_primitive_reader("long", src, idx_var_dest))
        # TODO special case optional fields, which have exactly two options, one
        # of which is null.

        idx_var_ref = Name(id=idx_var, ctx=Load())
        prev_if = None
        for idx, option in enumerate(options):
            if_idx_matches = Compare(
                left=idx_var_ref, ops=[Eq()], comparators=[Constant(idx)]
            )
            if_stmt = If(
                test=if_idx_matches,
                body=self._gen_reader(option, src, dest),
                orelse=[],
            )

            if prev_if is None:
                statements.append(if_stmt)
            else:
                prev_if.orelse = [if_stmt]
            prev_if = if_stmt

        return statements

    def _gen_record_reader(self, schema: Dict, src: Name, dest: AST) -> List[AST]:
        statements = []

        # Construct a new empty dictionary to hold the record contents.
        value_name = self.new_variable()
        empty_dict = DictLiteral(keys=[], values=[])
        statements.append(
            Assign(
                targets=[Name(id=value_name, ctx=Store())],
                value=empty_dict,
                lineno=0,
            ),
        )
        value_reference = Name(id=value_name, ctx=Load())

        # Write statements to populate all the fields of the record.
        for field in schema["fields"]:
            # Make an AST node that references an entry in the record dict,
            # using the field name as a key.
            field_dest = Subscript(
                value=value_reference,
                slice=Constant(value=field["name"]),
                ctx=Store(),
            )

            # Generate the statements required to read that field's type, and to
            # store it into field_dest.
            read_statements = self._gen_reader(field["type"], src, field_dest)
            statements.extend(read_statements)

        # Now that we have a fully constructed record, write it into the
        # destination provided.
        statements.append(
            Assign(
                targets=[dest],
                value=value_reference,
                lineno=0,
            )
        )
        return statements

    def _gen_array_reader(self, item_schema: SchemaType, src: Name, dest: AST) -> List[AST]:
        """
        Returns a sequence of statements which will deserialize an array of given
        type from src into dest.
        """
        statements = []

        # Create a new list to hold the values we'll read.
        list_varname = self.new_variable()
        assign_stmt = Assign(
            targets=[Name(id=list_varname, ctx=Store())],
            value=ListLiteral(elts=[], ctx=Load()),
        )
        statements.append(assign_stmt)

        # For each message in the array...
        for_each_message = []

        # ... read a value...
        value_varname = self.new_variable()
        value_dest = Name(id=value_varname, ctx=Store())
        read_statements = self._gen_reader(item_schema, src, value_dest)
        for_each_message.extend(read_statements)

        # ... and append it to the list.
        list_append_method = Attribute(
            value=Name(id=list_varname, ctx=Load()),
            attr="append",
            ctx=Load(),
        )
        list_append_method_call = Expr(Call(
            func=list_append_method,
            args=[Name(id=value_varname, ctx=Load())],
            keywords=[],
        ))
        for_each_message.append(list_append_method_call)

        statements.extend(self._gen_block_reader(for_each_message, src))

        # Finally, assign the list we have constructed into the destination AST node.
        assign_result = Assign(
            targets=[dest],
            value=[Name(id=list_varname, ctx=Load())],
        )
        statements.append(assign_result)
        return statements

    def _gen_map_reader(self, value_schema: SchemaType, src: Name, dest: AST) -> List[AST]:
        """
        Returns a sequence of statements which will deserialize a map with given
        value type from src into dest.
        """
        statements  = []
        map_varname = self.new_variable()
        assign_stmt = Assign(
            targets=[Name(id=map_varname, ctx=Store())],
            value=DictLiteral(keys=[], values=[]),
        )
        statements.append(assign_stmt)

        # For each message in a block...
        for_each_message = []

        # ... read a string key...
        key_varname = self.new_variable()
        key_dest = Name(id=key_varname, ctx=Store())
        for_each_message.extend(self._gen_primitive_reader("string", src, key_dest))
        # ... and read the corresponding value.
        value_varname = self.new_variable()
        value_dest = Subscript(
            value=Name(id=map_varname, ctx=Load()),
            slice=Name(id=key_varname, ctx=Load()),
            ctx=Store(),
        )
        for_each_message.extend(self._gen_reader(value_schema, src, value_dest))

        statements.extend(self._gen_block_reader(for_each_message, src))

        # Finally, assign our resulting map to the destination target.
        statements.append(
            Assign(
                targets=[dest],
                value=Name(map_varname, ctx=Load()),
            )
        )
        return statements

    def _gen_block_reader(self, for_each_message: List[AST], src: Name) -> List[AST]:
        """
        Returns a series of statements which represent iteration over an Avro record
        block, like are used for arrays and maps.

        Blocks are a series of records. The block is prefixed with a long that
        indicates the number of records in the block. A zero-length block
        indicates the end of the array or map.

        If a block's count is negative, its absolute value is used, and the
        count is followed immediately by a long block size indicating the number
        of bytes in the block

        for_each_message is a series of statements that will be injected and
        called for every message in the block.
        """
        statements = []

        # Read the blocksize to figure out how many messages to read.
        blocksize_varname = self.new_variable()
        blocksize_dest = Name(id=blocksize_varname, ctx=Store())
        statements.extend(self._gen_primitive_reader("long", src, blocksize_dest))

        # For each nonzero-sized block...
        while_loop = While(
            test=Compare(
                left=Name(id=blocksize_varname, ctx=Load()),
                ops=[NotEq()],
                comparators=[Constant(value=0)],
            ),
            body=[],
            orelse=[],
        )

        # ... handle negative block sizes...
        if_negative_blocksize = If(
            test=Compare(
                left=Name(id=blocksize_varname, ctx=Load()),
                ops=[Lt()],
                comparators=[Constant(value=0)],
            ),
            body=[],
            orelse=[]
        )
        flip_blocksize_sign = AugAssign(
            target=Name(id=blocksize_varname, ctx=Load()),
            op=Mult(),
            value=Constant(value=-1),
        )
        if_negative_blocksize.body.append(flip_blocksize_sign)
        # Just discard the byte size of the block.
        read_a_long = Expr(Call(
            func=Name(id="read_long", ctx=Load()),
            args=[src],
            keywords=[]
        ))
        if_negative_blocksize.body.append(read_a_long)
        while_loop.body.append(if_negative_blocksize)

        # Do a 'for _ in range(blocksize)' loop
        read_loop = For(
            target=Name(id="_", ctx=Store()),
            iter=Call(
                func=Name(id="range", ctx=Load()),
                args=[Name(id=blocksize_varname, ctx=Load())],
                keywords=[]
            ),
            body=for_each_message,
            orelse=[],
        )

        while_loop.body.append(read_loop)

        # If we've finished the block, read another long into blocksize.
        #
        # If it's zero, then we're done reading the array, and the loop test
        # will exit.
        #
        # If it's nonzero, then there are more messages to go.
        while_loop.body.extend(self._gen_primitive_reader("long", src, blocksize_dest))

        statements.append(while_loop)
        return statements

    def _gen_enum_reader(self, symbols: List[str], default: Optional[str], src: Name, dest: AST) -> List[AST]:
        statements = []

        # Construct a literal dictionary which maps integers to symbols.
        enum_map = DictLiteral(keys=[], values=[])
        for i, sym in enumerate(symbols):
            enum_map.keys.append(Constant(value=i))
            enum_map.values.append(Constant(value=sym))

        # Call dict.get(read_long(src), default=default)
        call = Call(
            func=Attribute(
                value=enum_map,
                attr="get",
                ctx=Load(),
            ),
            args=[
                Call(
                    func=Name(id="read_long", ctx=Load()),
                    args=[src],
                    keywords=[],
                )
            ],
            keywords=[]
        )

        if default is not None:
            call.args.append(Constant(value=default))

        statements.append(
            Assign(
                targets=[dest],
                value=call,
            )
        )
        return statements

    def _gen_fixed_reader(self, size: int, src: Name, dest: AST) -> List[AST]:
        # Call dest = src.read(size).

        read = Call(
            func=Attribute(value=src, attr="read", ctx=Load()),
            args=[Constant(value=size)],
            keywords=[],
        )

        statements = [
            Assign(
                targets=[dest],
                value=read,
            )
        ]
        return statements

    def _gen_primitive_reader(
        self, primitive_type: str, src: Name, dest: AST
    ) -> List[AST]:
        """
        Returns a sequence of statements which will deserialize a given primitive
        type from src into dest.
        """
        if primitive_type == "null":
            statement = Assign(
                targets=[dest],
                value=Constant(value=None),
            )
            return [statement]

        reader_func_name = PRIMITIVE_READERS[primitive_type]
        value = Call(
            func=Name(id=reader_func_name, ctx=Load()),
            args=[src],
            keywords=[],
        )
        statement = Assign(
            targets=[dest],
            value=value,
        )
        return [statement]

    def _gen_logical_reader(self, schema: SchemaType, src: Name, dest: AST) -> List[AST]:
        try:
            lt = schema["logicalType"]
            if lt == "decimal":
                return self._gen_decimal_reader(schema, src, dest)
            if lt == "uuid":
                return self._gen_uuid_reader(schema, src, dest)
            if lt == "date":
                return self._gen_date_reader(schema, src, dest)
            if lt == "time-millis":
                return self._gen_time_millis_reader(schema, src, dest)
            if lt == "time-micros":
                return self._gen_time_micros_reader(schema, src, dest)
            if lt == "timestamp-millis":
                return self._gen_timestamp_millis_reader(schema, src, dest)
            if lt == "timestamp-micros":
                return self._gen_timestamp_micros_reader(schema, src, dest)
            raise LogicalTypeError("unknown logical type")
        except LogicalTypeError:
            # If a logical type is unknown, or invalid, then we should fall back
            # and use the underlying Avro type. We do this by clearing the
            # logicalType field of the schema and calling self._gen_reader.
            schema = schema.copy()
            del schema["logicalType"]
            return self._gen_reader(schema, src, dest)

    def _gen_decimal_reader(self, schema: SchemaType, src: Name, dest: AST) -> List[AST]:
        scale = schema.get("scale", 0)
        precision = schema["precision"]
        if precision <= 0 or scale < 0 or scale > precision:
            raise LogicalTypeError("invalid decimal")

        statements = []

        # Read the raw bytes. They can be either 'fixed' or 'bytes'
        raw_bytes_varname = self.new_variable()
        raw_bytes_dest = Name(id=raw_bytes_varname, ctx=Store())
        if schema["type"] == "bytes":
            statements.extend(self._gen_primitive_reader("bytes", src, raw_bytes_dest))
        elif schema["type"] == "fixed":
            statements.extend(self._gen_fixed_reader(schema["size"], src, raw_bytes_dest))
        else:
            raise LogicalTypeError("unexpected type for decimal")

        # Parse the bytes.
        parse = Call(
            func=Name(id="read_decimal", ctx=Load()),
            args=[Name(id=raw_bytes_varname, ctx=Load())],
            keywords=[
                keyword(
                    arg="writer_schema",
                    value=DictLiteral(
                        keys=[Constant("precision"), Constant("scale")],
                        values=[Constant(precision), Constant(scale)]
                    )
                )
            ]
        )
        statements.append(
            Assign(
                targets=[dest],
                value=parse
            )
        )
        return statements

    def _gen_uuid_reader(self, schema: SchemaType, src: Name, dest: AST) -> List[AST]:
        if schema["type"] != "string":
            raise LogicalTypeError("unexpected type for uuid")
        return self._call_fastavro_logical_reader("string", "read_uuid", src, dest)

    def _gen_date_reader(self, schema: SchemaType, src: Name, dest: AST) -> List[AST]:
        if schema["type"] != "int":
            raise LogicalTypeError("unexpected type for date")
        return self._call_fastavro_logical_reader("int", "read_date", src, dest)

    def _gen_time_millis_reader(self, schema: SchemaType, src: Name, dest: AST) -> List[AST]:
        if schema["type"] != "int":
            raise LogicalTypeError("unexpected type for time-millis")
        return self._call_fastavro_logical_reader("int", "read_time_millis", src, dest)

    def _gen_time_micros_reader(self, schema: SchemaType, src: Name, dest: AST) -> List[AST]:
        if schema["type"] != "long":
            raise LogicalTypeError("unexpected type for time-micros")
        return self._call_fastavro_logical_reader("long", "read_time_micros", src, dest)

    def _gen_timestamp_millis_reader(self, schema: SchemaType, src: Name, dest: AST) -> List[AST]:
        if schema["type"] != "long":
            raise LogicalTypeError("unexpected type for timestamp-millis")
        return self._call_fastavro_logical_reader("long", "read_timestamp_millis", src, dest)

    def _gen_timestamp_micros_reader(self, schema: SchemaType, src: Name, dest: AST) -> List[AST]:
        if schema["type"] != "long":
            raise LogicalTypeError("unexpected type for timestamp-micros")
        return self._call_fastavro_logical_reader("long", "read_timestamp_micros", src, dest)

    def _call_fastavro_logical_reader(self, primitive_type: str, parser: str, src: Name, dest: AST) -> List[AST]:
        """
        Read a value of primitive type from src, and then call parser on it,
        assigning into dest.
        """
        statements = []
        # Read the raw value.
        raw_varname = self.new_variable()
        raw_dest = Name(id=raw_varname, ctx=Store())
        statements.extend(self._gen_primitive_reader(primitive_type, src, raw_dest))

        # Call the fastavro parser for the logical type.
        parse = Call(
            func=Name(id=parser, ctx=Load()),
            args=[Name(id=raw_varname, ctx=Load())],
            keywords=[]
        )
        statements.append(
            Assign(
                targets=[dest],
                value=parse
            )
        )
        return statements



class LogicalTypeError(Exception):
            pass
