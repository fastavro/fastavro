from __future__ import annotations

from typing import Dict, Any, Union, List, Callable, IO
from ast import (
    FunctionDef,
    Attribute,
    arguments,
    Compare,
    arg,
    Name,
    Load,
    Store,
    Expr,
    AugAssign,
    Add,
    Lt,
    Assign,
    Pass,
    For,
    While,
    If,
    AST,
    Call,
    Module,
    ImportFrom,
    alias,
    Constant,
    Subscript,
    Dict as DictLiteral,
    List as ListLiteral,
    fix_missing_locations,
    dump,
    unparse,
    Return,
    walk,
    parse,
    Eq,
    Gt,
    Expr,
)


PRIMITIVE_READERS = {
    "string": "read_utf8",
    "int": "read_long",
    "long": "read_long",
    "float": "read_float",
    "double": "read_double",
    "boolean": "read_boolean",
    "bytes": "read_bytes",
    "null": "read_null",
}


SchemaType = Union[
    str, # Primitives
    List['SchemaType'], # Unions
    Dict[str, Any], # Complex types
]


class SchemaParser:
    schema: SchemaType
    variable_count: int
    reader_name: str

    def __init__(self, schema: SchemaType, reader_name: str):
        self.schema = schema
        self.reader_name = reader_name
        self.variable_count = 0

    def new_variable(self) -> str:
        """
        Returns a new name for a variable which is guaranteed to be unique.
        """
        self.variable_count += 1
        return f"v{self.variable_count}"

    def compile(self, populate_linecache=True) -> Callable[[IO[bytes]], Any]:
        """
        Compile the schema and return a callable function which will read from a
        file-like byte source and produce a value determined by schema.
        """
        module = self.generate_module()

        if populate_linecache:
            import linecache
            source_code = unparse(module)
            filename = f"autogenerated_{self.reader_name}.py"
            compiled = compile(source_code, filename, mode="exec")
            source_lines = source_code.splitlines()
            linecache.cache[filename] = (len(source_lines), None, source_lines, filename)
        else:
            filename = "<generated>"
            compiled = compile(module, filename, mode="exec")
        namespace = {}
        exec(compiled, namespace)


        return namespace[self.reader_name]

    def generate_module(self) -> Module:
        import_from_fastavro_read = []
        for reader in PRIMITIVE_READERS.values():
            import_from_fastavro_read.append(alias(name=reader))

        body = [
            ImportFrom(
                module="fastavro._read",
                names=import_from_fastavro_read,
                level=0,
            ),
            self.generate_reader_func(),
        ]
        module = Module(
            body=body,
            type_ignores=[],
        )
        module = fix_missing_locations(module)
        return module

    def generate_reader_func(self) -> FunctionDef:
        """
        Returns an AST describing a function which can read an Avro message from a
        IO[bytes] source. The message is parsed according to the SchemaParser's
        schema.
        """
        src_var = Name(id="src", ctx=Load())
        result_var = Name(id=self.new_variable(), ctx=Store())
        body = []
        body.extend(self._gen_reader(self.schema, src_var, result_var))
        body.append(Return(value=Name(id=result_var.id, ctx=Load())))
        func = FunctionDef(
            name=self.reader_name,
            args=arguments(
                args=[arg("src")],
                posonlyargs=[],
                kwonlyargs=[],
                kw_defaults=[],
                defaults=[],
            ),
            body=body,
            decorator_list=[],
        )
        return func

    def _gen_reader(self, schema: SchemaType, src: Name, dest: AST) -> List[AST]:
        """
        Returns a sequence of statements which will read data from src and write
        the deserialized value into dest.
        """
        if isinstance(schema, str):
            if schema in PRIMITIVE_READERS.keys():
                return self._gen_primitive_reader(
                    primitive_type=schema, src=src, dest=dest
                )
            else:
                # TODO: Named type reference.
                pass
        if isinstance(schema, list):
            return self._gen_union_reader(
                options=schema,
                src=src,
                dest=dest,
            )
        if isinstance(schema, dict):
            schema_type = schema["type"]
            if schema_type in PRIMITIVE_READERS.keys():
                return self._gen_primitive_reader(
                    primitive_type=schema_type,
                    src=src,
                    dest=dest,
                )
            if schema_type == "record":
                return self._gen_record_reader(
                    schema=schema,
                    src=src,
                    dest=dest,
                )
            if schema_type == "array":
                return self._gen_array_reader(
                    item_schema=schema["items"],
                    src=src,
                    dest=dest,
                )
            if schema_type == "map":
                return self._gen_map_reader(
                    value_schema=schema["values"],
                    src=src,
                    dest=dest,
                )
            if schema_type == "fixed":
                raise NotImplementedError("fixed types not implemented")
            if schema_type == "enum":
                raise NotImplementedError("enum types not implemented")

        raise NotImplementedError(f"Schema type not implemented: {schema}")

    def _gen_union_reader(self, options: List[SchemaType], src: Name, dest: AST) -> List[AST]:
        statements = []
        # Read a long to figure out which option in the union is chosen.
        idx_var = self.new_variable()
        idx_var_dest = Name(id=idx_var, ctx=Store())
        statements.extend(self._gen_primitive_reader("long", src, idx_var_dest))
        # TODO special case optional fields, which have exactly two options, one
        # of which is null.

        idx_var_ref = Name(id=idx_var, ctx=Load())
        prev_if = None
        for idx, option in enumerate(options):
            if_idx_matches = Compare(
                left=idx_var_ref, ops=[Eq()], comparators=[Constant(idx)]
            )
            if_stmt = If(
                test=if_idx_matches,
                body=self._gen_reader(option, src, dest),
                orelse=[],
            )

            if prev_if is None:
                statements.append(if_stmt)
            else:
                prev_if.orelse = [if_stmt]
            prev_if = if_stmt

        return statements

    def _gen_record_reader(self, schema: Dict, src: Name, dest: AST) -> List[AST]:
        statements = []

        # Construct a new empty dictionary to hold the record contents.
        value_name = self.new_variable()
        empty_dict = DictLiteral(keys=[], values=[])
        statements.append(
            Assign(
                targets=[Name(id=value_name, ctx=Store())],
                value=empty_dict,
                lineno=0,
            ),
        )
        value_reference = Name(id=value_name, ctx=Load())

        # Write statements to populate all the fields of the record.
        for field in schema["fields"]:
            # Make an AST node that references an entry in the record dict,
            # using the field name as a key.
            field_dest = Subscript(
                value=value_reference,
                slice=Constant(value=field["name"]),
                ctx=Store(),
            )

            # Generate the statements required to read that field's type, and to
            # store it into field_dest.
            read_statements = self._gen_reader(field["type"], src, field_dest)
            statements.extend(read_statements)

        # Now that we have a fully constructed record, write it into the
        # destination provided.
        statements.append(
            Assign(
                targets=[dest],
                value=value_reference,
                lineno=0,
            )
        )
        return statements

    def _gen_array_reader(self, item_schema: SchemaType, src: Name, dest: AST) -> List[AST]:
        """
        Returns a sequence of statements which will deserialize an array of given
        type from src into dest.
        """
        statements = []

        # Create a new list to hold the values we'll read.
        list_varname = self.new_variable()
        assign_stmt = Assign(
            targets=[Name(id=list_varname, ctx=Store())],
            value=ListLiteral(elts=[], ctx=Load()),
        )
        statements.append(assign_stmt)

        # For each message in the array...
        for_each_message = []

        # ... read a value...
        value_varname = self.new_variable()
        value_dest = Name(id=value_varname, ctx=Store())
        read_statements = self._gen_reader(item_schema, src, value_dest)
        for_each_message.extend(read_statements)

        # ... and append it to the list.
        list_append_method = Attribute(
            value=Name(id=list_varname, ctx=Load()),
            attr="append",
            ctx=Load(),
        )
        list_append_method_call = Expr(Call(
            func=list_append_method,
            args=[Name(id=value_varname, ctx=Load())],
            keywords=[],
        ))
        for_each_message.append(list_append_method_call)

        statements.extend(self._gen_block_reader(for_each_message, src))

        # Finally, assign the list we have constructed into the destination AST node.
        assign_result = Assign(
            targets=[dest],
            value=[Name(id=list_varname, ctx=Load())],
        )
        statements.append(assign_result)
        return statements

    def _gen_map_reader(self, value_schema: SchemaType, src: Name, dest: AST) -> List[AST]:
        """
        Returns a sequence of statements which will deserialize a map with given
        value type from src into dest.
        """
        statements  = []
        map_varname = self.new_variable()
        assign_stmt = Assign(
            targets=[Name(id=map_varname, ctx=Store())],
            value=DictLiteral(keys=[], values=[]),
        )
        statements.append(assign_stmt)

        # For each message in a block...
        for_each_message = []

        # ... read a string key...
        key_varname = self.new_variable()
        key_dest = Name(id=key_varname, ctx=Store())
        for_each_message.extend(self._gen_primitive_reader("string", src, key_dest))
        # ... and read the corresponding value.
        value_varname = self.new_variable()
        value_dest = Subscript(
            value=Name(id=map_varname, ctx=Load()),
            slice=Name(id=key_varname, ctx=Load()),
            ctx=Store(),
        )
        for_each_message.extend(self._gen_reader(value_schema, src, value_dest))

        statements.extend(self._gen_block_reader(for_each_message, src))

        # Finally, assign our resulting map to the destination target.
        statements.append(
            Assign(
                targets=[dest],
                value=Name(map_varname, ctx=Load()),
            )
        )
        return statements

    def _gen_block_reader(self, for_each_message: List[AST], src: Name) -> List[AST]:
        """
        Returns a series of statements which represent iteration over an Avro record
        block, like are used for arrays and maps.

        Blocks are a series of records. The block is prefixed with a long that
        indicates the number of records in the block. A zero-length block
        indicates the end of the array or map.

        for_each_message is a series of statements that will be injected and
        called for every message in the block.
        """
        statements = []

        # Read the blocksize to figure out how many messages to read.
        blocksize_varname = self.new_variable()
        blocksize_dest = Name(id=blocksize_varname, ctx=Store())
        statements.extend(self._gen_primitive_reader("long", src, blocksize_dest))

        # For each nonzero-sized block...
        while_loop = While(
            test=Compare(
                left=Name(id=blocksize_varname, ctx=Load()),
                ops=[Gt()],
                comparators=[Constant(value=0)],
            ),
            body=[],
            orelse=[],
        )

        # .. keep a counter for number of messages we have read...
        n_read_varname = self.new_variable()
        while_loop.body.append(Assign(
            targets=[Name(id=n_read_varname, ctx=Store())],
            value=Constant(value=0),
        ))

        # ... iterate while the counter is less than the blocksize ...
        read_loop = While(
            test=Compare(
                left=Name(id=n_read_varname, ctx=Load()),
                ops=[Lt()],
                comparators=[Name(id=blocksize_varname, ctx=Load())],
            ),
            body=[],
            orelse=[],
        )
        while_loop.body.append(read_loop)

        # ... on each iteration, do the requested work...

        read_loop.body.extend(for_each_message)

        # ... and increment our count of messages read.
        increment_count = AugAssign(
            target=Name(id=n_read_varname, ctx=Store()),
            op=Add(),
            value=Constant(value=1),
        )
        read_loop.body.append(increment_count)

        # If we've finished the block, read another long into blocksize.
        #
        # If it's zero, then we're done reading the array, and the loop test
        # will exit.
        #
        # If it's nonzero, then there are more messages to go.
        while_loop.body.extend(self._gen_primitive_reader("long", src, blocksize_dest))

        statements.append(while_loop)
        return statements


    def _gen_primitive_reader(
        self, primitive_type: str, src: Name, dest: AST
    ) -> List[AST]:
        """
        Returns a sequence of statements which will deserialize a given primitive
        type from src into dest.
        """
        if primitive_type == "null":
            statement = Assign(
                targets=[dest],
                value=Constant(value=None),
            )
            return [statement]

        reader_func_name = PRIMITIVE_READERS[primitive_type]
        value = Call(
            func=Name(id=reader_func_name, ctx=Load()),
            args=[src],
            keywords=[],
        )
        statement = Assign(
            targets=[dest],
            value=value,
        )
        return [statement]
